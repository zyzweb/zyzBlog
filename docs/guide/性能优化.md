5s内打开页面

## 静态资源优化

压缩gif
Gifsicle：通过改变每帧比例，减小gif文件大小，同时可以使用透明来达到更小的
文件大小，目前公认的解决方案。
安装：
http://www.lcdf.orq/gifsicle/
使用方式：
优化级别设置为不小于2,1的汗甘大下r惊一-otimize=3-0out.gif in.gif
02:57
11:19
·将透明部分截去gifsicle-optimize=3-crop-transparency-oout.gif in.gif



<img src="https://image.zhuyuanzheng1.top/image-20220914000214127.png" alt="image-20220914000214127" style="zoom:33%;" />





图片服务器自动优化解密
·名词解释

* 图片服务器自动化优化是可以在图片URL链接上增加不同特殊参数，服务器自动化生成。
* ·不同格式、大小、质量的图片。


处理方式

* 图片裁剪：按长边、短边、填充、拉伸等缩放。
* 图片格式转换：支持JPG,GIF,PNG,WbP等，支持不同的图片压缩率。
* 图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框等。
* A!能力：鉴黄以及智能抠图、智能排版、智能配色、智能合成等A!功能。



文件放在合适位置
·CSS样式文件链接尽量放在页面头部
CSS加载不会阻塞DOM tree解析，但是会阻塞DOM Tree渲染，也会阻塞后面JS执行。
任何body元素之前，可以确保在文档部分中解析了所有CSS样式（内联和外联)，从而减
少了浏览器必须重排文档的次数。如果放置页面底部，就要等待最后一个CSS文件下载完成，
此时会出现"白屏"，影响用户体验。
·JS引用放在HTML底部
·防止」S的加载、解析、执行对阻塞页面后续元素的正常渲染。

提升CSS渲染性能
提升CSS渲染性能
·谨慎使用expensive属性
·如：nth-child伪类；position:fixed定位
·尽量减少样式层级数
·如div ul li span i{color:blue;}
·尽量避免使用占用过多CUP和内存的属性
·如text-indnt:-99999px
·尽量避免使用耗电量大的属性
.如CSS33 D transforms5、Css tranoro、opaciy



合理使用Web Fonts
·将字体部署在CDN上
·将字体以base64形式保存在CSS中并通过localStorage进行缓存
·Google字体库因为某些不可抗拒原因，应该使用国内托管服务



CSS动画优化
·尽量避免同时动画
延迟动画初始化
·结合SVG



用docker将node_modules打包成二进制文件

用本地缓存减少接口请求



### link标签



prefetch   preload  preconnect  dns-prefetch   apple-touch-icon  canonical   prerender

preconnect可以看成是升级版的dns-prefetch prerender是preconnect的升级版

[preload、prefetch和preconnect的简单介绍](https://www.naeco.top/2021/02/28/preload-prefetch-preconnect/)

https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types



![image-20220630163706897](https://image.zhuyuanzheng1.top/image-20220630163706897.png)





### preload && prefetch

**preload** 预加载  当前页面需要用到的资源 优先级比prefetch高

被放入memory cache

在解析css和js的同时下载,强制浏览器在不阻塞 document的onload事件的情况下请求资源

使用as或type属性表示资源的优先级as="style"优先级最高

需要提供as属性,否则导致获取2次

preload 字体不带crossorigin也将会二次获取,需要加上





网络-优先级可以查看资源加载的优先级属性

<img src="https://image.zhuyuanzheng1.top/image-20220707175215232.png" alt="image-20220707175215232" style="zoom:30%;" />



没有用到的 `preload` 资源在 Chrome 的 `console` 里会在 onload 事件 3s 后发生警告

<img src="https://image.zhuyuanzheng1.top/image-20220707175441719.png" alt="image-20220707175441719" style="zoom:33%;" />

**prefetch** 预读取      

以后可能会用到的资源比如其他网页、继续滚动才会加载的资源等

有2种分为prefetch和dns-prefetch(用于跨域资源,常用于CDN、以及请求第三方资源，比如google font、google analytics等)

在 Chrome中,如果用户导航离开一个页面,而对其他页面的预取请求仍在进行中,这些请求将不会被终止

无论资源的可缓存性如何，prefetch请求在未指定的网络堆栈缓存中至少保存 5 分钟



### lighthouse检测性能







### 性能优化指标

**FP**

**FCP**

**LCP**





### 页面生命周期 (document.readyState查看)

**DOMContentLoaded** 在DOM 树准备就绪在document上触发  **document.addEventListener("DOMContentLoaded", ready)**

页面在解析时遇到script会停止解析dom,因为js可能操作dom, DOMContentLoaded在js执行完之后触发,但是包含async的js不会阻塞

**load**   在页面所有资源加载完毕之后在window上触发   **window.addEventListener('load', callback)**

**unload**  在页面卸载的时候触发   window.addEventListener("unload", function() {  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData)); })

**baforeunload**  在页面卸载之前触发 window.addEventListener("baforeunloadunload", callback)



### defer与async (type=module相当于defer)

script放在顶部会阻塞页面,放尾部可能加载时间过长,后面才下载js执行js,放顶部可以使用defer和async来避免阻塞页面,同时可以并行下载js

defer属性的script 不会阻塞页面,会在dom解析完毕以及其他js执行完毕在执行,在DOMContentLoaded之前执行,相当于单线程顺序执行,script依赖dom或者其他第三方库需要这样设置

async属性的script 不会阻塞页面 会在后台运行,跟dom和其他script执行完全独立,相当于多线程在另外一个线程运行

defe和asyncr可以不用放在body尾部,避免了放尾部加载时间过长



### import与require

import和export一起使用  属于es6模块 简称esm  **浏览器和node通用**  浏览器上使用type=module  node中使用.mjs或者在package.json中定义

"type": "module"   .mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置

使用import()动态加载类似require()但是前者异步,后者同步   node13.2版本开始支持

编译时加载可以静态分析和类型检测,treeshaking依赖import export





require()和module.export一起使用   属于commonjs模块   **只能在node上用**

运行时加载不可以静态分析和类型检测



### 参考链接

[网页版lighthouse](https://juejin.cn/)

[google - 页面速度测速工具](https://pagespeed.web.dev/)

[web性能优化系列](https://blog.fundebug.com/2019/04/11/understand-preload-and-prefetch/)

[掘金-模块化](https://juejin.cn/post/6870141103958589454#heading-12)

